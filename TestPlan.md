# План тестирования
## Описание классов и методов классов
### Модуль game.py

### Класс Snake
#### \# Класс: змейка
Атрибуты:
*	segments – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела змеи (последний элемент списка [-1] – голова змеи)
*	length – длина змеи (количество блоков в теле)
*	x – координата x змеи(головы змеи) на поле
*	y – координата y змеи(головы змеи) на поле
*	x_change – вектор перемещения змеи (головы змеи) по оси x на текущем шаге
*	y_change – вектор перемещения змеи (головы змеи) по оси y на текущем шаге

Методы:
#### \# Конструктор объекта класса
```python
def __init__(self, segments):
```

Аргументы: segments – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела змеи (последний элемент списка [-1] – голова змеи) (начальное состояние змеи)

Возвращаемые значения: –

Метод определяет атрибуты класса: segments, length, x, y, x_change, y_change

> Метод не тестируется, так как отвечает лишь за инициализацию объектов, не содержит в себе дополнительной логики

#### \# Возвращает длину тела змеи
```python
def __len__(self):
    return len(self.segments)
```

Аргументы: –

Возвращаемые значения: длина тела змеи (количество сегментов в теле)

#### \# Проверка столкновения (проигрышной ситуации) змейки с самой собой или с другой змейкой
```python
def collision_check_with(self, another_snake_list):
    return True/False
```

Аргументы: another _snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела змеи (другой) (последний элемент списка [-1] – голова змеи)

Возвращаемые значения: True – проигрыш (окончание игры), змейка столкнулась с самой собой/с другой змейкой/False – игра продолжается (расположение змейки на данном шаге не проигрышное, столкновения нет)

#### \# Проверка окончания игры (проигрышной ситуации врезания в границы поля)
```python
def losing_situation(self):
    return True/False
```

Аргументы: –

Возвращаемые значения: True – проигрыш (окончание игры)/False – игра продолжается (расположение змейки на данном шаге не проигрышное)

#### \# Перемещение змеи на шаг (всех блоков тела) в координатах и увеличение длины, если змея заработала очко
```python
def move_snake_blocks(snake_list, x_coord, y_coord, length_of_snake):
```

Аргументы: –

Возвращаемые значения: –

Метод изменяет атрибут класса: segments

#### \# Проверка нахождения змейкой еды (увеличение счета)
```python
def find_food(self, food_x, food_y):
    return True/False
```

Аргументы: 
*	food_x – координата x расположения еды (яблока) на поле, 
*	food_y – координата y расположения еды (яблока)  на поле

Возвращаемые значения: True – змейка нашла еду -> начисление 1 очка змее (увеличение длины тела на 1)/False – змейка не нашла еду (количество очков и длина тела сохраняется у обеих)

Метод изменяет атрибут класса: length

#### \# Проверка, может ли змейка сделать шаг в новые координаты без проигрыша
Protected метод
```python
@protected
def _can_take_a_step(self, x, y, another_snake_list):
    return True/False
```

Аргументы: 
*	x – новая координата x, в которую змейка хочет сделать шаг (проверяет, может ли сделать шаг)
*	y – новая координата y, в которую змейка хочет сделать шаг (проверяет, может ли сделать шаг)
*	another _snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела змеи (другой) (последний элемент списка [-1] – голова змеи)

Возвращаемые значения: True – змейка может сделать шаг в новые координаты без проигрыша/False – змейка не может сделать шаг в новые координаты без проигрыша

### Класс CompetitorSnake
#### \# Класс: самостоятельная (игровая) змейка-соперник (наследуется от класса змейка)
Наследуется от класса Snake

Атрибуты: те же, что и у класса-родителя Snake

Методы:

У класса CompetitorSnake нет своего конструктора, поэтому он наследует его от родителя Snake

#### \# Расчет следующего шага змеи-соперника
```python
def independent_snake_movement(self, food_x, food_y, controlled_snake_list):
```

Аргументы: 
*	food_x – координата x расположения еды (яблока) на поле, 
*	food_y – координата y расположения еды (яблока)  на поле,
*	controlled_snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела управляемой змеи (последний элемент списка [-1] – голова змеи)

Возвращаемые значения: –

Метод изменяет атрибут класса: x_change или y_change

#### Статический метод для доступа к protected методу _can_take_a_step класса-родителя Snake
```python
@staticmethod
def static_check_can_move(competitor_list, x, y, controlled_list):
  return comp_snake._can_take_a_step(x, y, controlled_list)
```

Аргументы: 
*	competitor_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела змеи-соперника,
*	x – новая координата x, в которую змейка хочет сделать шаг (проверяет, может ли сделать шаг), 
*	y – новая координата y, в которую змейка хочет сделать шаг (проверяет, может ли сделать шаг),
*	controlled _list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела управляемой змеи

Возвращаемые значения: True/False – возвращаемые значения метода _can_take_a_step  

### Класс Food
#### \# Класс: еда (яблоко)
Атрибуты:
*	x – координата x расположения еды (яблока) на поле
*	y – координата y расположения еды (яблока)  на поле

Методы:
#### \# Конструктор объекта класса -> вычисление случайных координат для яблока на поле
(метод создает объект класса Food, выдает подходящие случайные значения для размещения еды внутри игрового поля и устанавливает их в атрибуты x, y объекта)
```python
def __init__(self, controlled_snake_list, competitor_snake_list, width, height):
```

Аргументы: 
*	controlled_snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела управляемой змеи (последний элемент списка [-1] – голова змеи)
*	competitor_snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела змеи-противника (последний элемент списка [-1] – голова змеи), 
*	width – значение ширины игрового поля, внутри которого должны быть новые координаты яблока,
*	height – значение высоты игрового поля, внутри которого должны быть новые координаты яблока

Возвращаемые значения: –

Метод определяет атрибуты класса: x и y (координаты расположения еды)

### Основной цикл игры
#### \# Основной цикл игры
```python
def game_loop(game_over=False)
```

Аргументы: game_over=False (дефолтное значение переменной – игра не окончена)

Возвращаемые значения: –

> Функция не тестируется, так как отвечает лишь за отслеживание нажатий пользователя на клавиатуру, определение объектов классов и вызовы методов классов (которые тестируются отдельно), не содержит в себе логики.

### Модуль drawing.py
### Класс Display
#### \# Класс: дисплей (поле отрисовки)

Атрибуты:
*	dis – поверхность отрисовки
*	width – значение ширины игрового поля
*	height – значение высоты игрового поля

Методы:
#### \# Конструктор объекта класса
```python
def __init__(self, display, dis_width, dis_height):
```

Аргументы: 
*	display – поверхность отрисовки
*	dis_width – значение ширины игрового поля
*	dis_height – значение высоты игрового поля

Возвращаемые значения: –

Метод определяет атрибуты класса: dis, width, height

> Метод не тестируется, так как отвечает лишь за инициализацию объектов, не содержит в себе дополнительной логики

#### \# Отрисовка счета (для обеих змеек) на экране игры
```python
def show_scores(self, score1, score2):
```

Аргументы: score1 – значение счета управляемой змейки, score2 – значение счета змейки-противника

Возвращаемые значения: –

> Метод не тестируется, так как отвечает лишь за отрисовку объектов, не содержит в себе логики и не может привести к ошибкам.

#### \# Отрисовка счета (для одной змейки) на экране игры
```python
def _show_score(self, score, color, text, x_coord, score_font):
```

Protected метод

Аргументы: score – значение счета змейки, color – цвет отрисовки, text – текст для вывода, x_coord – координата x размещения надписи, score_font – шрифт

Возвращаемые значения: –

> Метод не тестируется, так как отвечает лишь за отрисовку объектов, не содержит в себе логики и не может привести к ошибкам.

#### \# Вывод сообщения на экран игры
```python
def message(self, msg, x_coord, y_coord):
```

Аргументы: msg – текст сообщения, x_coord – координата x размещения надписи, y_coord – координата y размещения надписи

Возвращаемые значения: –

> Метод не тестируется, так как отвечает лишь за отрисовку объектов, не содержит в себе логики и не может привести к ошибкам.

#### \# Отрисовка змей на экране игры
```python
def draw_snakes(self, snake_block, controlled_snake_list, competitor_snake_list):
```

Аргументы: snake_block – размер одного блока тела змеи, controlled_snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела управляемой змеи, competitor_snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела змеи-противника

Возвращаемые значения: –

> Метод не тестируется, так как отвечает лишь за отрисовку объектов, не содержит в себе логики и не может привести к ошибкам.

#### \# Отрисовка змеи (каждого блока) на экране игры
```python
def _draw_snake(self, snake_block, snake_list, color):
```

Protected метод

Аргументы: snake_block – размер одного блока тела змеи, snake_list – список (list, в котором каждый элемент – это list [x, y]) координат расположения всех блоков тела змеи, color – цвет отрисовки

Возвращаемые значения: –

> Метод не тестируется, так как отвечает лишь за отрисовку объектов, не содержит в себе логики и не может привести к ошибкам.

#### \# Отрисовка фона
```python
def draw_background(self):
```

Аргументы: –

Возвращаемые значения: –

> Метод не тестируется, так как отвечает лишь за отрисовку объектов, не содержит в себе логики и не может привести к ошибкам.

#### \# Отрисовка основных объектов
```python
def draw_field(self, foodx, foody, snake_block):
```

Аргументы: foodx – координата x расположения еды на поле, foody – координата y расположения еды на поле, snake_block – размер одного блока тела змеи

Возвращаемые значения: –

> Метод не тестируется, так как отвечает лишь за отрисовку объектов, не содержит в себе логики и не может привести к ошибкам.
 
## Тесты
### Блочные тесты: 
1.	Блочный тест на метод Snake.losing_situation (позитивный)
def test_not_losing_situation_positive(self)
Проверка assertFalse():False – ситуация не проигрышная
Входные данные: [[200, 300]] – список сегментов тела змейки для создания объекта Snake
Ожидаемый результат: False
Тест пройден

2.	Блочный тест на метод Snake.losing_situation (позитивный)
def test_not_losing_situation_positive_2(self)
Проверка assertFalse():False – ситуация не проигрышная (краевой случай)
Входные данные: [[590, 390]] – список сегментов тела змейки для создания объекта Snake
Ожидаемый результат: False
Тест пройден

3.	Блочный тест на метод Snake.losing_situation (негативный)
def test_losing_situation_negative(self)
Проверка assertTrue ():True - ситуация проигрышная (краевой случай)
Входные данные: [[600, 400]] – список сегментов тела змейки для создания объекта Snake
Ожидаемый результат: True
Тест пройден


4.	Блочный тест на метод Snake.losing_situation (негативный) 
def test_losing_situation_negative_2 (self)
Проверка assertTrue ():True - ситуация проигрышная (краевой случай)
Входные данные: [[-10, -10]] – список сегментов тела змейки для создания объекта Snake
Ожидаемый результат: True
Тест пройден

5.	Блочный тест на метод Snake.collision_check _with (позитивный)
def test_not_collision_check _with_positive(self)
Проверка assertFalse():False – ситуация не проигрышная (Змейки не врезаются)
Входные данные:
[[230.0, 350.0]] – список сегментов тела змейки для создания объекта Snake
[[290.0, 370.0], [290.0, 380.0]] – список сегментов тела другой змейки
Ожидаемый результат: False
Тест пройден

6.	Блочный тест на метод Snake.collision_check _with (негативный)
def test_collision_check_with_negative_1(self)
Проверка assertTrue ():True - ситуация проигрышная (Змейка врезалась в другую)
Входные данные:
[[230.0, 350.0]] – список сегментов тела змейки для создания объекта Snake
[[280.0, 360.0], [280.0, 350.0], [280.0, 340.0]]– список сегментов тела другой змейки
Ожидаемый результат: True
Тест пройден

7.	Блочный тест на метод Snake.collision_check _with (негативный)
def test_collision_check_with_negative_2(self)
Проверка assertTrue ():True - ситуация проигрышная (Змейка врезалась в себя)
Входные данные:
 [[150.0, 200.0], [150.0, 210.0], [150.0, 220.0], [160.0, 220.0], [160.0, 210.0], [150.0, 210.0]] – список сегментов тела змейки для создания объекта Snake
[[210.0, 170.0], [220.0, 170.0], [220.0, 160.0], [230.0, 160.0], [240.0, 160.0], [250.0, 160.0], [260.0, 160.0], [270.0, 160.0], [280.0, 160.0], [290.0, 160.0]] – список сегментов тела другой змейки
Ожидаемый результат: True
Тест пройден

8.	Блочный тест на метод Snake.find_food (позитивный)
def test_find_food_positive(self)
Проверка assertTrue() – Змейка нашла еду (координаты головы совпали с координатой еды)
Входные данные: 400.0, 160.0 – координаты еды; [[400.0, 160.0]] – список сегментов тела змейки для создания объекта Snake
Ожидаемый результат: True
Тест пройден

9.	Блочный тест на метод Snake.find_food (негативный)
def test_find_food_negative(self)
Проверка assertFalse() – Змейка не нашла еду (координаты головы не совпали с координатой еды)
Входные данные: 150.0, 210.0 – координаты еды; [[580.0, 200.0]] – список сегментов тела змейки для создания объекта Snake
Ожидаемый результат: False
Тест пройден

10.	Блочный тест на метод Snake.move_snake_blocks (позитивный)
def test_move_snake_blocks_positive(self)
Проверка assertEqual ()
Входные данные: [[120.0, 90.0], [120.0, 80.0]] – список сегментов тела змейки для создания объекта Snake, 130.0, 80.0 – новые координаты головы змейки, +1 – добавление очка (увеличение длины тела змейки до 3)
С увеличением длины при добавлением очка
Ожидаемый результат: [[120.0, 90.0], [120.0, 80.0], [130.0, 80.0]]
Тест пройден

11.	Блочный тест на метод Snake.move_snake_blocks (позитивный)
def test_move_snake_blocks_positive_2(self)
Проверка assertEqual ()
Входные данные: [[100.0, 140.0], [100.0, 130.0]] – список сегментов тела змейки для создания объекта Snake, 100.0, 120.0 – новые координаты головы змейки
Без увеличения длины без добавления очка 
Ожидаемый результат: [[100.0, 130.0], [100.0, 120.0]]
Тест пройден

12.	Блочный тест на метод Snake.move_snake_blocks (негативный)
Проигрыш при шаге за поле (выход за пределы поля без добавления очка)
def test_move_snake_blocks_negative(self)
Проверка assertEqual ()
Входные данные: [[580.0, 110.0], [590.0, 110.0]] – список сегментов тела змейки для создания объекта класса Snake, 600.0, 110.0 – новые координаты головы змейки
Ожидаемый результат: [[590.0, 110.0], [600.0, 110.0]]
Тест пройден

13.	Блочный тест на метод Snake.move_snake_blocks (негативный)
Змейка занимает всё поле и выходит за него (при добавлении очка)
def test_move_snake_blocks_negative_2(self)
Проверка assertEqual ()
Входные данные: full_screen_snake_list – список сегментов тела змейки для создания объекта класса Snake, 400.0, 0.0 – новые координаты головы змейки, +1 – добавление очка (увеличение длины тела змейки до len(full_screen_snake_list) + 1)
Ожидаемый результат: full_screen_snake_list_new
Тест пройден

14.	Блочный тест на метод CompetitorSnake.independent_snake_movement (позитивный)
С mock-объектом на вызываемый метод losing_situation
def test_unit_independent_snake_movement_positive(self)
Проверка assertEqual ()
Входные данные: 
[[150.0, 270.0], [150.0, 280.0]] – список сегментов тела змейки для создания объекта класса CompetitorSnake,
180.0, 310.0 – координаты положения еды на поле, [[600.0, 200.0]] – список сегментов тела управляемой змейки
Ожидаемый результат: (10, 0)
Тест пройден

15.	Блочный тест на метод CompetitorSnake.independent_snake_movement (негативный)
С mock-объектом на вызываемую функцию losing_situation
def test_unit_independent_snake_movement_negative(self)
Проверка assertEqual ()
Входные данные: 
 [[430.0, 220.0], [440.0, 220.0], [440.0, 230.0], [450.0, 230.0], [450.0, 240.0], [460.0, 240.0], [460.0, 250.0], [470.0, 250.0], [470.0, 260.0], [480.0, 260.0], [480.0, 270.0], [490.0, 270.0], [490.0, 280.0], [500.0, 280.0], [500.0, 290.0], [490.0, 290.0], [480.0, 290.0], [470.0, 290.0], [460.0, 290.0], [450.0, 290.0], [440.0, 290.0], [430.0, 290.0], [420.0, 290.0], [410.0, 290.0], [400.0, 290.0], [390.0, 290.0], [390.0, 280.0], [390.0, 270.0], [390.0, 260.0], [390.0, 250.0], [400.0, 250.0], [400.0, 240.0], [410.0, 240.0], [410.0, 230.0], [420.0, 230.0], [420.0, 240.0], [420.0, 250.0], [410.0, 250.0], [410.0, 260.0], [400.0, 260.0], [400.0, 270.0], [400.0, 280.0], [410.0, 280.0], [410.0, 270.0], [420.0, 270.0], [420.0, 260.0], [430.0, 260.0], [430.0, 250.0], [430.0, 240.0], [430.0, 230.0], [430.0, 230.0]] – список сегментов тела змейки для создания объекта класса CompetitorSnake, 
20.0, 90.0 – координаты положения еды на поле, 
[[400.0, 200.0]] – список сегментов тела управляемой змейки
Ожидаемый результат: (0, 0) -> нет возможных перемещений
Тест пройден

16.	Блочный тест на метод Food.__init__ (позитивный)
def test_random_food_position_when_init_positive(self)
Проверка assertTrue (): True - функция выдает подходящие случайные значения для размещения еды внутри игрового поля
Входные данные:
Для создания объекта класса Food:
[[720.0, 250.0], [730.0, 250.0]] – список сегментов тела управляемой змейки,
[[560.0, 160.0], [560.0, 150.0], [570.0, 150.0], [570.0, 140.0]] – список сегментов тела змейки-соперника, 600 – ширина игрового поля, 400 – высота игрового поля
Ожидаемый результат: True
Тест пройден

17.	Блочный тест на метод Food.__init__ (негативный)
def test_random_food_position_when_init_negative(self)
Проверка assertTrue (): True – функция выдает подходящие случайные значения для размещения еды внутри игрового поля, указанного в значениях width и height
Входные данные:
Для создания объекта класса Food:
[[720.0, 250.0], [730.0, 250.0]] – список сегментов тела управляемой змейки,
[[560.0, 160.0], [560.0, 150.0], [570.0, 150.0], [570.0, 140.0]] – список сегментов тела змейки-соперника, width (1000) – ширина игрового поля, height (300) – высота игрового поля
Ожидаемый результат: True
Тест пройден

18.	Блочный тест на метод Snake._can_take_a_step (позитивный)
def test_can_take_a_step_positive(self):
Проверка assertTrue(): True – змейка может сделать шаг в новые координаты без проигрыша 
Проверка protected метода через статический метода static_check_can_move класса CompetitorSnake
Входные данные:
[[250.0, 200.0], [260.0, 200.0]] – список сегментов тела змейки-соперника, 270.0, 200.0 – координаты x и y для нового шага, [[400.0, 200.0]] – список сегментов тела управляемой змейки
Ожидаемый результат: True
Тест пройден

19.	Блочный тест на метод Snake._can_take_a_step (негативный)
def test_can_take_a_step_negative(self):
Проверка assertFalse(): False – змейка не может сделать шаг в новые координаты без проигрыша
Проверка protected метода через статический метода static_check_can_move класса CompetitorSnake
Входные данные:
[[250.0, 200.0], [260.0, 200.0]] – список сегментов тела змейки-соперника, 270.0, 200.0 – координаты x и y для нового шага, [[270.0, 200.0]] – список сегментов тела управляемой змейки
Ожидаемый результат: False
Тест пройден
 

### Интеграционные тесты:
1.	Интеграционный тест на метод CompetitorSnake.independent_snake_movement (позитивный)
def test_integration_independent_snake_movement_positive(self)
Взаимодействие: метод CompetitorSnake.independent_snake_movement -> вызываемый метод Snake.losing_situation
Проверка assertEqual ()
Входные данные: 230.0, 50.0 – координаты положения еды на поле, [[260.0, 90.0], [260.0, 80.0], [250.0, 80.0]] – список сегментов тела змейки для создания объекта класса CompetitorSnake, [[400.0, 200.0]] – список сегментов тела управляемой змейки
Ожидаемый результат: (0, -10)
Тест пройден

2.	Интеграционный тест на метод CompetitorSnake.independent_snake_movement (негативный)
def test_integration_independent_snake_movement_negative(self)
Взаимодействие: метод CompetitorSnake.independent_snake_movement -> вызываемый метод Snake.losing_situation
Проверка assertEqual ()
Входные данные: 
310.0, 230.0  – координаты положения еды на поле, 
[[430.0, 80.0], [440.0, 80.0], [440.0, 70.0], [430.0, 70.0], [420.0, 70.0], [420.0, 80.0], [410.0, 80.0], [410.0, 90.0], [400.0, 90.0], [400.0, 100.0], [390.0, 100.0], [380.0, 100.0], [370.0, 100.0], [360.0, 100.0], [350.0, 100.0], [340.0, 100.0], [330.0, 100.0], [320.0, 100.0], [310.0, 100.0], [310.0, 90.0], [320.0, 90.0], [330.0, 90.0], [340.0, 90.0], [350.0, 90.0], [360.0, 90.0], [370.0, 90.0], [380.0, 90.0], [390.0, 90.0], [390.0, 80.0], [380.0, 80.0], [370.0, 80.0], [360.0, 80.0], [350.0, 80.0], [340.0, 80.0], [330.0, 80.0], [320.0, 80.0], [310.0, 80.0], [310.0, 70.0], [320.0, 70.0], [330.0, 70.0], [340.0, 70.0], [350.0, 70.0], [360.0, 70.0], [370.0, 70.0], [380.0, 70.0], [390.0, 70.0], [400.0, 70.0], [400.0, 80.0], [400.0, 80.0]] – список сегментов тела змейки для создания объекта класса CompetitorSnake, 
[[400.0, 200.0]] – список сегментов тела управляемой змейки
Ожидаемый результат: (0, 0) -> нет возможных перемещений
Тест пройден

3.	Интеграционные тесты на метод game_loop -> Метод не тестируется, так как отвечает лишь за отслеживание нажатий пользователя на клавиатуру, определение объектов классов и вызовы методов классов (которые тестируются отдельно), не содержит в себе логики.

 
### Аттестационные тесты:
1.	Тест A1(позитивный)
Начальное состояние: игра не открыта
Действие: пользователь запускает игру
Ожидаемый результат: появляется экран игры “Змейка” (на экране 2 змейки и яблоко), змейка противник начинает двигаться за яблоком, управляемая змейка ждёт сигнал управления с клавиатуры
Тест проверяет запуск игры

2.	Тест A2(позитивный)
Начальное состояние: игра запущена
Действие: пользователь нажимает на крестик – закрытие окна игры
Ожидаемый результат: окно игры закрывается
Тест проверяет закрытие игры в любой момент работы игры при нажатии на крестик

3.	Тест A3(позитивный)
Начальное состояние: игра запущена
Действие: пользователь нажимает на стрелку (вправо/влево/вверх/вниз) на клавиатуре
Ожидаемый результат: управляемая (фиолетовая) змейка двигается в соответствии с выбранным направлением
Тест проверяет реакцию игры на действия пользователя (нажатия на стрелки)

4.	Тест A4(позитивный)
Начальное состояние: игра запущена
Действие: голова управляемой змейки (или змейки соперника аналогично) попадает на клетку с яблоком
Ожидаемый результат: змейке, которая поймала яблоко начисляется очко, яблоко появляется в другой случайной клетке поля
Тест проверяет реакцию игры на то, что змейка поймала яблоко

5.	Тест A5(негативный)
Начальное состояние: игра запущена
Действие: голова управляемой змейки (или змейки соперника аналогично) выходит за пределы поля или врезается в своё тело или в тело другой змейки
Ожидаемый результат: игра заканчивается, выигрывает змейка, у которой на момент окончания игры было очков (соответствующие надписи выводятся на экран игры)
Тест проверяет реакцию игры на проигрыш (конец игры)

6.	Тест A6(позитивный)
Начальное состояние: игра запущена, на экране заголовки об окончании игры
Действие: пользователь нажимает на клавишу C на клавиатуре
Ожидаемый результат: начинается новая игра
Тест проверяет реакцию игры на запуск новой игры после проигрыша (окончания игры)

7.	Тест A7(позитивный)
Начальное состояние: игра запущена, на экране заголовки об окончании игры
Действие: пользователь нажимает на клавишу Q на клавиатуре
Ожидаемый результат: окно игры закрывается
Тест проверяет закрытие игры после проигрыша (окончания игры) по нажатию клавиши
